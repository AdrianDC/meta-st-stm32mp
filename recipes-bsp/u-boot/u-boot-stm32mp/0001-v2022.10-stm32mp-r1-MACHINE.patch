From b7313d66e5d6c15489ca456d8a95aff9553e07df Mon Sep 17 00:00:00 2001
From: Romuald Jeanne <romuald.jeanne@st.com>
Date: Mon, 5 Jun 2023 11:59:34 +0200
Subject: [PATCH 1/5] v2022.10-stm32mp-r1 MACHINE

Signed-off-by: Romuald Jeanne <romuald.jeanne@st.com>
---
 arch/arm/mach-stm32mp/Kconfig                 |  14 +-
 arch/arm/mach-stm32mp/Kconfig.13x             |   4 +-
 arch/arm/mach-stm32mp/Kconfig.15x             |   8 +-
 arch/arm/mach-stm32mp/Makefile                |   5 +-
 arch/arm/mach-stm32mp/bsec.c                  | 180 +++++++++-
 arch/arm/mach-stm32mp/cmd_stm32key.c          | 329 +++++++++++++-----
 .../cmd_stm32prog/cmd_stm32prog.c             |  33 +-
 .../mach-stm32mp/cmd_stm32prog/stm32prog.c    | 155 +++++----
 .../mach-stm32mp/cmd_stm32prog/stm32prog.h    |  33 +-
 .../cmd_stm32prog/stm32prog_serial.c          |  17 +-
 .../cmd_stm32prog/stm32prog_usb.c             |   6 +-
 arch/arm/mach-stm32mp/etzpc.c                 | 205 +++++++++++
 arch/arm/mach-stm32mp/fdt.c                   | 266 +-------------
 arch/arm/mach-stm32mp/include/mach/bsec.h     |   7 +
 arch/arm/mach-stm32mp/include/mach/etzpc.h    |  32 ++
 arch/arm/mach-stm32mp/include/mach/stm32.h    |  16 +-
 .../mach-stm32mp/include/mach/stm32mp1_smc.h  |  38 +-
 .../arm/mach-stm32mp/include/mach/stm32prog.h |   6 -
 .../arm/mach-stm32mp/include/mach/sys_proto.h |   1 +
 arch/arm/mach-stm32mp/pwr_regulator.c         |   5 +
 arch/arm/mach-stm32mp/stm32mp15x.c            |   5 +-
 21 files changed, 856 insertions(+), 509 deletions(-)
 create mode 100644 arch/arm/mach-stm32mp/etzpc.c
 create mode 100644 arch/arm/mach-stm32mp/include/mach/etzpc.h

diff --git a/arch/arm/mach-stm32mp/Kconfig b/arch/arm/mach-stm32mp/Kconfig
index db47baba6d1..349c7d25a33 100644
--- a/arch/arm/mach-stm32mp/Kconfig
+++ b/arch/arm/mach-stm32mp/Kconfig
@@ -35,9 +35,9 @@ config ENV_SIZE
 
 choice
 	prompt "Select STMicroelectronics STM32MPxxx Soc"
-	default STM32MP15x
+	default STM32MP15X
 
-config STM32MP13x
+config STM32MP13X
 	bool "Support STMicroelectronics STM32MP13x Soc"
 	select ARM_SMCCC
 	select CPU_V7A
@@ -55,7 +55,7 @@ config STM32MP13x
 		support of STMicroelectronics SOC STM32MP13x family
 		STMicroelectronics MPU with core ARMv7
 
-config STM32MP15x
+config STM32MP15X
 	bool "Support STMicroelectronics STM32MP15x Soc"
 	select ARCH_SUPPORT_PSCI
 	select BINMAN
@@ -101,14 +101,6 @@ config SYS_MMCSD_RAW_MODE_U_BOOT_PARTITION_MMC2
 	  Partition on the second MMC to load U-Boot from when the MMC is being
 	  used in raw mode
 
-config STM32_ETZPC
-	bool "STM32 Extended TrustZone Protection"
-	depends on STM32MP15x || STM32MP13x
-	default y
-	imply BOOTP_SERVERIP
-	help
-	  Say y to enable STM32 Extended TrustZone Protection
-
 config STM32_ECDSA_VERIFY
 	bool "STM32 ECDSA verification via the ROM API"
 	depends on SPL_ECDSA_VERIFY
diff --git a/arch/arm/mach-stm32mp/Kconfig.13x b/arch/arm/mach-stm32mp/Kconfig.13x
index 5fc000986e1..e03acc7af7e 100644
--- a/arch/arm/mach-stm32mp/Kconfig.13x
+++ b/arch/arm/mach-stm32mp/Kconfig.13x
@@ -1,10 +1,10 @@
-if STM32MP13x
+if STM32MP13X
 
 choice
 	prompt "STM32MP13x board select"
 	optional
 
-config TARGET_ST_STM32MP13x
+config TARGET_ST_STM32MP13X
 	bool "STMicroelectronics STM32MP13x boards"
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
diff --git a/arch/arm/mach-stm32mp/Kconfig.15x b/arch/arm/mach-stm32mp/Kconfig.15x
index d516270292a..882a580339c 100644
--- a/arch/arm/mach-stm32mp/Kconfig.15x
+++ b/arch/arm/mach-stm32mp/Kconfig.15x
@@ -1,6 +1,6 @@
-if STM32MP15x
+if STM32MP15X
 
-config STM32MP15x_STM32IMAGE
+config STM32MP15X_STM32IMAGE
 	bool "Support STM32 image for generated U-Boot image"
 	depends on TFABOOT
 	help
@@ -11,7 +11,7 @@ choice
 	prompt "STM32MP15x board select"
 	optional
 
-config TARGET_ST_STM32MP15x
+config TARGET_ST_STM32MP15X
 	bool "STMicroelectronics STM32MP15x boards"
 	imply BOOTSTAGE
 	imply CMD_BOOTSTAGE
@@ -117,7 +117,7 @@ endif
 if DEBUG_UART
 
 config DEBUG_UART_BOARD_INIT
-	default y
+	default y if SPL
 
 # debug on UART4 by default
 config DEBUG_UART_BASE
diff --git a/arch/arm/mach-stm32mp/Makefile b/arch/arm/mach-stm32mp/Makefile
index 1db9057e049..3f85bf7f664 100644
--- a/arch/arm/mach-stm32mp/Makefile
+++ b/arch/arm/mach-stm32mp/Makefile
@@ -7,9 +7,10 @@ obj-y += cpu.o
 obj-y += dram_init.o
 obj-y += syscon.o
 obj-y += bsec.o
+obj-y += etzpc.o
 
-obj-$(CONFIG_STM32MP13x) += stm32mp13x.o
-obj-$(CONFIG_STM32MP15x) += stm32mp15x.o
+obj-$(CONFIG_STM32MP13X) += stm32mp13x.o
+obj-$(CONFIG_STM32MP15X) += stm32mp15x.o
 
 ifdef CONFIG_SPL_BUILD
 obj-y += spl.o
diff --git a/arch/arm/mach-stm32mp/bsec.c b/arch/arm/mach-stm32mp/bsec.c
index c00130b08b3..0dc1e5c3fdc 100644
--- a/arch/arm/mach-stm32mp/bsec.c
+++ b/arch/arm/mach-stm32mp/bsec.c
@@ -10,9 +10,11 @@
 #include <dm.h>
 #include <log.h>
 #include <misc.h>
+#include <tee.h>
 #include <asm/io.h>
 #include <asm/arch/bsec.h>
 #include <asm/arch/stm32mp1_smc.h>
+#include <dm/device.h>
 #include <dm/device_compat.h>
 #include <linux/arm-smccc.h>
 #include <linux/iopoll.h>
@@ -63,10 +65,43 @@
  */
 #define BSEC_LOCK_PROGRAM		0x04
 
+#define PTA_BSEC_UUID { 0x94cf71ad, 0x80e6, 0x40b5, \
+	{ 0xa7, 0xc6, 0x3d, 0xc5, 0x01, 0xeb, 0x28, 0x03 } }
+
+/*
+ * Read OTP memory
+ *
+ * [in]		value[0].a		OTP start offset in byte
+ * [in]		value[0].b		Access type (0:shadow, 1:fuse, 2:lock)
+ * [out]	memref[1].buffer	Output buffer to store read values
+ * [out]	memref[1].size		Size of OTP to be read
+ *
+ * Return codes:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ * TEE_ERROR_ACCESS_DENIED - OTP not accessible by caller
+ */
+#define PTA_BSEC_READ_MEM		0x0
+
 /*
- * OTP status: bit 0 permanent lock
+ * Write OTP memory
+ *
+ * [in]		value[0].a		OTP start offset in byte
+ * [in]		value[0].b		Access type (0:shadow, 1:fuse, 2:lock)
+ * [in]		memref[1].buffer	Input buffer to read values
+ * [in]		memref[1].size		Size of OTP to be written
+ *
+ * Return codes:
+ * TEE_SUCCESS - Invoke command success
+ * TEE_ERROR_BAD_PARAMETERS - Incorrect input param
+ * TEE_ERROR_ACCESS_DENIED - OTP not accessible by caller
  */
-#define BSEC_LOCK_PERM			BIT(0)
+#define PTA_BSEC_WRITE_MEM		0x1
+
+/* value of PTA_BSEC access type = value[in] b */
+#define SHADOW_ACCESS			0
+#define FUSE_ACCESS			1
+#define LOCK_ACCESS			2
 
 /**
  * bsec_lock() - manage lock for each type SR/SP/SW
@@ -359,6 +394,10 @@ struct stm32mp_bsec_plat {
 	u32 base;
 };
 
+struct stm32mp_bsec_priv {
+	struct udevice *tee;
+};
+
 static int stm32mp_bsec_read_otp(struct udevice *dev, u32 *val, u32 otp)
 {
 	struct stm32mp_bsec_plat *plat;
@@ -468,18 +507,111 @@ static int stm32mp_bsec_write_lock(struct udevice *dev, u32 val, u32 otp)
 	plat = dev_get_plat(dev);
 
 	return bsec_permanent_lock_otp(dev, plat->base, otp);
+}
+
+static int bsec_pta_open_session(struct udevice *tee, u32 *tee_session)
+{
+	const struct tee_optee_ta_uuid uuid = PTA_BSEC_UUID;
+	struct tee_open_session_arg arg;
+	int rc;
+
+	memset(&arg, 0, sizeof(arg));
+	tee_optee_ta_uuid_to_octets(arg.uuid, &uuid);
+	arg.clnt_login = TEE_LOGIN_REE_KERNEL;
+	rc = tee_open_session(tee, &arg, 0, NULL);
+	if (rc < 0)
+		return -ENODEV;
+
+	*tee_session = arg.session;
+
+	return 0;
+}
+
+static int bsec_optee_open(struct udevice *dev)
+{
+	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
+	struct udevice *tee;
+	u32 tee_session;
+	int rc;
+
+	tee = tee_find_device(NULL, NULL, NULL, NULL);
+	if (!tee)
+		return -ENODEV;
+
+	/* try to open the STM32 BSEC TA */
+	rc = bsec_pta_open_session(tee, &tee_session);
+	if (rc)
+		return rc;
+
+	tee_close_session(tee, tee_session);
 
-	return -EINVAL;
+	priv->tee = tee;
+
+	return 0;
+}
+
+static int bsec_optee_pta(struct udevice *dev, int cmd, int type, int offset,
+			  void *buff, ulong size)
+{
+	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
+	u32 tee_session;
+	struct tee_invoke_arg arg;
+	struct tee_param param[2];
+	struct tee_shm *fw_shm;
+	int rc;
+
+	rc = bsec_pta_open_session(priv->tee, &tee_session);
+	if (rc)
+		return rc;
+
+	rc = tee_shm_register(priv->tee, buff, size, 0, &fw_shm);
+	if (rc)
+		goto close_session;
+
+	memset(&arg, 0, sizeof(arg));
+	arg.func = cmd;
+	arg.session = tee_session;
+
+	memset(param, 0, sizeof(param));
+
+	param[0].attr = TEE_PARAM_ATTR_TYPE_VALUE_INPUT;
+	param[0].u.value.a = offset;
+	param[0].u.value.b = type;
+
+	if (cmd == PTA_BSEC_WRITE_MEM)
+		param[1].attr = TEE_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	else
+		param[1].attr = TEE_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+
+	param[1].u.memref.shm = fw_shm;
+	param[1].u.memref.size = size;
+
+	rc = tee_invoke_func(priv->tee, &arg, 2, param);
+	if (rc < 0 || arg.ret != 0) {
+		dev_err(priv->tee,
+			"PTA_BSEC invoke failed TEE err: %x, err:%x\n",
+			arg.ret, rc);
+		if (!rc)
+			rc = -EIO;
+	}
+
+	tee_shm_free(fw_shm);
+
+close_session:
+	tee_close_session(priv->tee, tee_session);
+
+	return rc;
 }
 
 static int stm32mp_bsec_read(struct udevice *dev, int offset,
 			     void *buf, int size)
 {
+	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
 	int ret;
 	int i;
 	bool shadow = true, lock = false;
 	int nb_otp = size / sizeof(u32);
-	int otp;
+	int otp, cmd;
 	unsigned int offs = offset;
 
 	if (offs >= STM32_BSEC_LOCK_OFFSET) {
@@ -490,9 +622,22 @@ static int stm32mp_bsec_read(struct udevice *dev, int offset,
 		shadow = false;
 	}
 
-	if ((offs % 4) || (size % 4))
+	if ((offs % 4) || (size % 4) || !size)
 		return -EINVAL;
 
+	if (IS_ENABLED(CONFIG_OPTEE) && priv->tee) {
+		cmd = FUSE_ACCESS;
+		if (shadow)
+			cmd = SHADOW_ACCESS;
+		if (lock)
+			cmd = LOCK_ACCESS;
+		ret = bsec_optee_pta(dev, PTA_BSEC_READ_MEM, cmd, offs, buf, size);
+		if (ret)
+			return ret;
+
+		return size;
+	}
+
 	otp = offs / sizeof(u32);
 
 	for (i = otp; i < (otp + nb_otp) && i <= BSEC_OTP_MAX_VALUE; i++) {
@@ -517,11 +662,12 @@ static int stm32mp_bsec_read(struct udevice *dev, int offset,
 static int stm32mp_bsec_write(struct udevice *dev, int offset,
 			      const void *buf, int size)
 {
+	struct stm32mp_bsec_priv *priv = dev_get_priv(dev);
 	int ret = 0;
 	int i;
 	bool shadow = true, lock = false;
 	int nb_otp = size / sizeof(u32);
-	int otp;
+	int otp, cmd;
 	unsigned int offs = offset;
 
 	if (offs >= STM32_BSEC_LOCK_OFFSET) {
@@ -532,9 +678,22 @@ static int stm32mp_bsec_write(struct udevice *dev, int offset,
 		shadow = false;
 	}
 
-	if ((offs % 4) || (size % 4))
+	if ((offs % 4) || (size % 4) || !size)
 		return -EINVAL;
 
+	if (IS_ENABLED(CONFIG_OPTEE) && priv->tee) {
+		cmd = FUSE_ACCESS;
+		if (shadow)
+			cmd = SHADOW_ACCESS;
+		if (lock)
+			cmd = LOCK_ACCESS;
+		ret = bsec_optee_pta(dev, PTA_BSEC_WRITE_MEM, cmd, offs, (void *)buf, size);
+		if (ret)
+			return ret;
+
+		return size;
+	}
+
 	otp = offs / sizeof(u32);
 
 	for (i = otp; i < otp + nb_otp && i <= BSEC_OTP_MAX_VALUE; i++) {
@@ -583,6 +742,9 @@ static int stm32mp_bsec_probe(struct udevice *dev)
 			return ret;
 	}
 
+	if (IS_ENABLED(CONFIG_OPTEE))
+		bsec_optee_open(dev);
+
 	/*
 	 * update unlocked shadow for OTP cleared by the rom code
 	 * only executed in SPL, it is done in TF-A for TFABOOT
@@ -599,6 +761,7 @@ static int stm32mp_bsec_probe(struct udevice *dev)
 }
 
 static const struct udevice_id stm32mp_bsec_ids[] = {
+	{ .compatible = "st,stm32mp13-bsec" },
 	{ .compatible = "st,stm32mp15-bsec" },
 	{}
 };
@@ -608,7 +771,8 @@ U_BOOT_DRIVER(stm32mp_bsec) = {
 	.id = UCLASS_MISC,
 	.of_match = stm32mp_bsec_ids,
 	.of_to_plat = stm32mp_bsec_of_to_plat,
-	.plat_auto	= sizeof(struct stm32mp_bsec_plat),
+	.plat_auto = sizeof(struct stm32mp_bsec_plat),
+	.priv_auto = sizeof(struct stm32mp_bsec_priv),
 	.ops = &stm32mp_bsec_ops,
 	.probe = stm32mp_bsec_probe,
 };
diff --git a/arch/arm/mach-stm32mp/cmd_stm32key.c b/arch/arm/mach-stm32mp/cmd_stm32key.c
index 68f28922d1e..b2e6421e9a2 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32key.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32key.c
@@ -8,16 +8,82 @@
 #include <console.h>
 #include <log.h>
 #include <misc.h>
+#include <asm/arch/bsec.h>
 #include <dm/device.h>
 #include <dm/uclass.h>
 
-/* Closed device : bit 6 of OPT0*/
+/*
+ * Closed device: OTP0
+ * STM32MP15x: bit 6 of OPT0
+ * STM32MP13x: 0b111111 = 0x3F for OTP_SECURED closed device
+ */
 #define STM32_OTP_CLOSE_ID		0
-#define STM32_OTP_CLOSE_MASK		BIT(6)
+#define STM32_OTP_STM32MP13X_CLOSE_MASK	0x3F
+#define STM32_OTP_STM32MP15X_CLOSE_MASK	BIT(6)
+
+/* PKH is the first element of the key list */
+#define STM32KEY_PKH 0
+
+struct stm32key {
+	char *name;
+	char *desc;
+	u8 start;
+	u8 size;
+};
+
+const struct stm32key stm32mp13_list[] = {
+	[STM32KEY_PKH] = {
+		.name = "PKHTH",
+		.desc = "Hash of the 8 ECC Public Keys Hashes Table (ECDSA is the authentication algorithm)",
+		.start = 24,
+		.size = 8,
+	},
+	{
+		.name = "EDMK",
+		.desc = "Encryption/Decryption Master Key",
+		.start = 92,
+		.size = 4,
+	}
+};
+
+const struct stm32key stm32mp15_list[] = {
+	[STM32KEY_PKH] = {
+		.name = "PKH",
+		.desc = "Hash of the ECC Public Key (ECDSA is the authentication algorithm)",
+		.start = 24,
+		.size = 8,
+	}
+};
+
+/* index of current selected key in stm32key list, 0 = PKH by default */
+static u8 stm32key_index;
+
+static u8 get_key_nb(void)
+{
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return ARRAY_SIZE(stm32mp13_list);
 
-/* HASH of key: 8 OTPs, starting with OTP24) */
-#define STM32_OTP_HASH_KEY_START	24
-#define STM32_OTP_HASH_KEY_SIZE		8
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return ARRAY_SIZE(stm32mp15_list);
+}
+
+static const struct stm32key *get_key(u8 index)
+{
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return &stm32mp13_list[index];
+
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return &stm32mp15_list[index];
+}
+
+static u32 get_otp_close_mask(void)
+{
+	if (IS_ENABLED(CONFIG_STM32MP13X))
+		return STM32_OTP_STM32MP13X_CLOSE_MASK;
+
+	if (IS_ENABLED(CONFIG_STM32MP15X))
+		return STM32_OTP_STM32MP15X_CLOSE_MASK;
+}
 
 static int get_misc_dev(struct udevice **dev)
 {
@@ -30,108 +96,115 @@ static int get_misc_dev(struct udevice **dev)
 	return ret;
 }
 
-static void read_hash_value(u32 addr)
+static void read_key_value(const struct stm32key *key, u32 addr)
 {
 	int i;
 
-	printf("Read KEY at 0x%x\n", addr);
-	for (i = 0; i < STM32_OTP_HASH_KEY_SIZE; i++) {
-		printf("OTP value %i: %x\n", STM32_OTP_HASH_KEY_START + i,
-		       __be32_to_cpu(*(u32 *)addr));
+	for (i = 0; i < key->size; i++) {
+		printf("%s OTP %i: [%08x] %08x\n", key->name, key->start + i,
+		       addr, __be32_to_cpu(*(u32 *)addr));
 		addr += 4;
 	}
 }
 
-static int read_hash_otp(bool print, bool *locked, bool *closed)
+static int read_key_otp(struct udevice *dev, const struct stm32key *key, bool print, bool *locked)
 {
-	struct udevice *dev;
 	int i, word, ret;
-	int nb_invalid = 0, nb_zero = 0, nb_lock = 0;
+	int nb_invalid = 0, nb_zero = 0, nb_lock = 0, nb_lock_err = 0;
 	u32 val, lock;
 	bool status;
 
-	ret = get_misc_dev(&dev);
-	if (ret)
-		return ret;
-
-	for (i = 0, word = STM32_OTP_HASH_KEY_START; i < STM32_OTP_HASH_KEY_SIZE; i++, word++) {
+	for (i = 0, word = key->start; i < key->size; i++, word++) {
 		ret = misc_read(dev, STM32_BSEC_OTP(word), &val, 4);
 		if (ret != 4)
 			val = ~0x0;
 		ret = misc_read(dev, STM32_BSEC_LOCK(word), &lock, 4);
 		if (ret != 4)
-			lock = -1;
+			lock = BSEC_LOCK_ERROR;
 		if (print)
-			printf("OTP HASH %i: %x lock : %d\n", word, val, lock);
+			printf("%s OTP %i: %08x lock : %08x\n", key->name, word, val, lock);
 		if (val == ~0x0)
 			nb_invalid++;
 		else if (val == 0x0)
 			nb_zero++;
-		if (lock == 1)
+		if (lock & BSEC_LOCK_PERM)
 			nb_lock++;
+		if (lock & BSEC_LOCK_ERROR)
+			nb_lock_err++;
 	}
 
-	word = STM32_OTP_CLOSE_ID;
-	ret = misc_read(dev, STM32_BSEC_OTP(word), &val, 4);
-	if (ret != 4)
-		val = 0x0;
-	ret = misc_read(dev, STM32_BSEC_LOCK(word), &lock, 4);
-	if (ret != 4)
-		lock = -1;
-
-	status = (val & STM32_OTP_CLOSE_MASK) == STM32_OTP_CLOSE_MASK;
-	if (closed)
-		*closed = status;
-	if (print)
-		printf("OTP %d: closed status: %d lock : %d\n", word, status, lock);
-
-	status = (nb_lock == STM32_OTP_HASH_KEY_SIZE);
+	status = nb_lock_err || (nb_lock == key->size);
 	if (locked)
 		*locked = status;
-	if (!status && print)
-		printf("Hash of key is not locked!\n");
+	if (nb_lock_err && print)
+		printf("%s lock is invalid!\n", key->name);
+	else if (!status && print)
+		printf("%s is not locked!\n", key->name);
 
-	if (nb_invalid == STM32_OTP_HASH_KEY_SIZE) {
+	if (nb_invalid == key->size) {
 		if (print)
-			printf("Hash of key is invalid!\n");
+			printf("%s is invalid!\n", key->name);
 		return -EINVAL;
 	}
-	if (nb_zero == STM32_OTP_HASH_KEY_SIZE) {
+	if (nb_zero == key->size) {
 		if (print)
-			printf("Hash of key is free!\n");
+			printf("%s is free!\n", key->name);
 		return -ENOENT;
 	}
 
 	return 0;
 }
 
-static int fuse_hash_value(u32 addr, bool print)
+static int read_close_status(struct udevice *dev, bool print, bool *closed)
+{
+	int word, ret, result;
+	u32 val, lock, mask;
+	bool status;
+
+	result = 0;
+	word = STM32_OTP_CLOSE_ID;
+	ret = misc_read(dev, STM32_BSEC_OTP(word), &val, 4);
+	if (ret < 0)
+		result = ret;
+	if (ret != 4)
+		val = 0x0;
+
+	ret = misc_read(dev, STM32_BSEC_LOCK(word), &lock, 4);
+	if (ret < 0)
+		result = ret;
+	if (ret != 4)
+		lock = BSEC_LOCK_ERROR;
+
+	mask = get_otp_close_mask();
+	status = (val & mask) == mask;
+	if (closed)
+		*closed = status;
+	if (print)
+		printf("OTP %d: closed status: %d lock : %08x\n", word, status, lock);
+
+	return result;
+}
+
+static int fuse_key_value(struct udevice *dev, const struct stm32key *key, u32 addr, bool print)
 {
-	struct udevice *dev;
 	u32 word, val;
 	int i, ret;
 
-	ret = get_misc_dev(&dev);
-	if (ret)
-		return ret;
-
-	for (i = 0, word = STM32_OTP_HASH_KEY_START;
-	     i < STM32_OTP_HASH_KEY_SIZE;
-	     i++, word++, addr += 4) {
+	for (i = 0, word = key->start; i < key->size; i++, word++, addr += 4) {
 		val = __be32_to_cpu(*(u32 *)addr);
 		if (print)
-			printf("Fuse OTP %i : %x\n", word, val);
+			printf("Fuse %s OTP %i : %08x\n", key->name, word, val);
 
 		ret = misc_write(dev, STM32_BSEC_OTP(word), &val, 4);
 		if (ret != 4) {
-			log_err("Fuse OTP %i failed\n", word);
+			log_err("Fuse %s OTP %i failed\n", key->name, word);
 			return ret;
 		}
-		/* on success, lock the OTP for HASH key */
-		val = 1;
+		/* on success, lock the OTP for the key */
+		val = BSEC_LOCK_PERM;
 		ret = misc_write(dev, STM32_BSEC_LOCK(word), &val, 4);
 		if (ret != 4) {
-			log_err("Lock OTP %i failed\n", word);
+			log_err("Lock %s OTP %i failed\n", key->name, word);
 			return ret;
 		}
 	}
@@ -153,28 +226,103 @@ static int confirm_prog(void)
 	return 0;
 }
 
+static void display_key_info(const struct stm32key *key)
+{
+	printf("%s : %s\n", key->name, key->desc);
+	printf("\tOTP%d..%d\n", key->start, key->start + key->size);
+}
+
+static int do_stm32key_list(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	int i;
+
+	for (i = 0; i < get_key_nb(); i++)
+		display_key_info(get_key(i));
+
+	return CMD_RET_SUCCESS;
+}
+
+static int do_stm32key_select(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	const struct stm32key *key;
+	int i;
+
+	if (argc == 1) {
+		printf("Selected key:\n");
+		key = get_key(stm32key_index);
+		display_key_info(key);
+		return CMD_RET_SUCCESS;
+	}
+
+	for (i = 0; i < get_key_nb(); i++) {
+		key = get_key(i);
+		if (!strcmp(key->name, argv[1])) {
+			printf("%s selected\n", key->name);
+			stm32key_index = i;
+			return CMD_RET_SUCCESS;
+		}
+	}
+
+	printf("Unknown key %s\n", argv[1]);
+
+	return CMD_RET_FAILURE;
+}
+
 static int do_stm32key_read(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
+	const struct stm32key *key;
+	struct udevice *dev;
 	u32 addr;
+	int ret, i;
+	int result;
+
+	ret = get_misc_dev(&dev);
 
 	if (argc == 1) {
-		read_hash_otp(true, NULL, NULL);
+		if (ret)
+			return CMD_RET_FAILURE;
+		key = get_key(stm32key_index);
+		ret = read_key_otp(dev, key, true, NULL);
+		if (ret != -ENOENT)
+			return CMD_RET_FAILURE;
 		return CMD_RET_SUCCESS;
 	}
 
+	if (!strcmp("-a", argv[1])) {
+		if (ret)
+			return CMD_RET_FAILURE;
+		result = CMD_RET_SUCCESS;
+		for (i = 0; i < get_key_nb(); i++) {
+			key = get_key(i);
+			ret = read_key_otp(dev, key, true, NULL);
+			if (ret != -ENOENT)
+				result = CMD_RET_FAILURE;
+		}
+		ret = read_close_status(dev, true, NULL);
+		if (ret)
+			result = CMD_RET_FAILURE;
+
+		return result;
+	}
+
 	addr = hextoul(argv[1], NULL);
 	if (!addr)
 		return CMD_RET_USAGE;
 
-	read_hash_value(addr);
+	key = get_key(stm32key_index);
+	printf("Read %s at 0x%08x\n", key->name, addr);
+	read_key_value(key, addr);
 
 	return CMD_RET_SUCCESS;
 }
 
 static int do_stm32key_fuse(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
+	const struct stm32key *key = get_key(stm32key_index);
+	struct udevice *dev;
 	u32 addr;
-	bool yes = false, lock, closed;
+	int ret;
+	bool yes = false, lock;
 
 	if (argc < 2)
 		return CMD_RET_USAGE;
@@ -189,29 +337,38 @@ static int do_stm32key_fuse(struct cmd_tbl *cmdtp, int flag, int argc, char *con
 	if (!addr)
 		return CMD_RET_USAGE;
 
-	if (read_hash_otp(!yes, &lock, &closed) != -ENOENT) {
+	ret = get_misc_dev(&dev);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	if (read_key_otp(dev, key, !yes, &lock) != -ENOENT) {
 		printf("Error: can't fuse again the OTP\n");
 		return CMD_RET_FAILURE;
 	}
-
-	if (lock || closed) {
-		printf("Error: invalid OTP configuration (lock=%d, closed=%d)\n", lock, closed);
+	if (lock) {
+		printf("Error: %s is locked\n", key->name);
 		return CMD_RET_FAILURE;
 	}
 
+	if (!yes) {
+		printf("Writing %s with\n", key->name);
+		read_key_value(key, addr);
+	}
+
 	if (!yes && !confirm_prog())
 		return CMD_RET_FAILURE;
 
-	if (fuse_hash_value(addr, !yes))
+	if (fuse_key_value(dev, key, addr, !yes))
 		return CMD_RET_FAILURE;
 
-	printf("Hash key updated !\n");
+	printf("%s updated !\n", key->name);
 
 	return CMD_RET_SUCCESS;
 }
 
 static int do_stm32key_close(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 {
+	const struct stm32key *key;
 	bool yes, lock, closed;
 	struct udevice *dev;
 	u32 val;
@@ -224,32 +381,36 @@ static int do_stm32key_close(struct cmd_tbl *cmdtp, int flag, int argc, char *co
 		yes = true;
 	}
 
-	ret = read_hash_otp(!yes, &lock, &closed);
-	if (ret) {
-		if (ret == -ENOENT)
-			printf("Error: OTP not programmed!\n");
+	ret = get_misc_dev(&dev);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	if (read_close_status(dev, !yes, &closed))
 		return CMD_RET_FAILURE;
-	}
 
 	if (closed) {
 		printf("Error: already closed!\n");
 		return CMD_RET_FAILURE;
 	}
 
+	/* check PKH status before to close */
+	key = get_key(STM32KEY_PKH);
+	ret = read_key_otp(dev, key, !yes, &lock);
+	if (ret) {
+		if (ret == -ENOENT)
+			printf("Error: %s not programmed!\n", key->name);
+		return CMD_RET_FAILURE;
+	}
 	if (!lock)
-		printf("Warning: OTP not locked!\n");
+		printf("Warning: %s not locked!\n", key->name);
 
 	if (!yes && !confirm_prog())
 		return CMD_RET_FAILURE;
 
-	ret = get_misc_dev(&dev);
-	if (ret)
-		return CMD_RET_FAILURE;
-
-	val = STM32_OTP_CLOSE_MASK;
+	val = get_otp_close_mask();
 	ret = misc_write(dev, STM32_BSEC_OTP(STM32_OTP_CLOSE_ID), &val, 4);
 	if (ret != 4) {
-		printf("Error: can't update OTP\n");
+		printf("Error: can't update OTP %d\n", STM32_OTP_CLOSE_ID);
 		return CMD_RET_FAILURE;
 	}
 
@@ -259,11 +420,15 @@ static int do_stm32key_close(struct cmd_tbl *cmdtp, int flag, int argc, char *co
 }
 
 static char stm32key_help_text[] =
-	"read [<addr>]: Read the hash stored at addr in memory or in OTP\n"
-	"stm32key fuse [-y] <addr> : Fuse hash stored at addr in OTP\n"
-	"stm32key close [-y] : Close the device, the hash stored in OTP\n";
-
-U_BOOT_CMD_WITH_SUBCMDS(stm32key, "Fuse ST Hash key", stm32key_help_text,
+	"list : list the supported key with description\n"
+	"stm32key select [<key>] : Select the key identified by <key> or display the key used for read/fuse command\n"
+	"stm32key read [<addr> | -a ] : Read the curent key at <addr> or current / all (-a) key in OTP\n"
+	"stm32key fuse [-y] <addr> : Fuse the current key at addr in OTP\n"
+	"stm32key close [-y] : Close the device\n";
+
+U_BOOT_CMD_WITH_SUBCMDS(stm32key, "Manage key on STM32", stm32key_help_text,
+	U_BOOT_SUBCMD_MKENT(list, 1, 0, do_stm32key_list),
+	U_BOOT_SUBCMD_MKENT(select, 2, 0, do_stm32key_select),
 	U_BOOT_SUBCMD_MKENT(read, 2, 0, do_stm32key_read),
 	U_BOOT_SUBCMD_MKENT(fuse, 3, 0, do_stm32key_fuse),
 	U_BOOT_SUBCMD_MKENT(close, 2, 0, do_stm32key_close));
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c b/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
index f59414e716f..465589d02ac 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/cmd_stm32prog.c
@@ -61,7 +61,7 @@ static int do_stm32prog(struct cmd_tbl *cmdtp, int flag, int argc,
 
 	dev = (int)dectoul(argv[2], NULL);
 
-	addr = STM32_DDR_BASE;
+	addr = CONFIG_SYS_LOAD_ADDR;
 	size = 0;
 	if (argc > 3) {
 		addr = hextoul(argv[3], NULL);
@@ -126,21 +126,21 @@ static int do_stm32prog(struct cmd_tbl *cmdtp, int flag, int argc,
 		char *bootm_argv[5] = {
 			"bootm", boot_addr_start, "-", dtb_addr, NULL
 		};
-		u32 uimage = data->uimage;
-		u32 dtb = data->dtb;
-		u32 initrd = data->initrd;
+		const void *uimage = (void *)data->uimage;
+		const void *dtb = (void *)data->dtb;
+		const void *initrd = (void *)data->initrd;
 
 		if (!dtb)
 			bootm_argv[3] = env_get("fdtcontroladdr");
 		else
 			snprintf(dtb_addr, sizeof(dtb_addr) - 1,
-				 "0x%x", dtb);
+				 "0x%p", dtb);
 
 		snprintf(boot_addr_start, sizeof(boot_addr_start) - 1,
-			 "0x%x", uimage);
+			 "0x%p", uimage);
 
 		if (initrd) {
-			snprintf(initrd_addr, sizeof(initrd_addr) - 1, "0x%x:0x%x",
+			snprintf(initrd_addr, sizeof(initrd_addr) - 1, "0x%p:0x%zx",
 				 initrd, data->initrd_size);
 			bootm_argv[2] = initrd_addr;
 		}
@@ -148,7 +148,7 @@ static int do_stm32prog(struct cmd_tbl *cmdtp, int flag, int argc,
 		printf("Booting kernel at %s %s %s...\n\n\n",
 		       boot_addr_start, bootm_argv[2], bootm_argv[3]);
 		/* Try bootm for legacy and FIT format image */
-		if (genimg_get_format((void *)uimage) != IMAGE_FORMAT_INVALID)
+		if (genimg_get_format(uimage) != IMAGE_FORMAT_INVALID)
 			do_bootm(cmdtp, 0, 4, bootm_argv);
 		else if (CONFIG_IS_ENABLED(CMD_BOOTZ))
 			do_bootz(cmdtp, 0, 4, bootm_argv);
@@ -180,20 +180,3 @@ U_BOOT_CMD(stm32prog, 5, 0, do_stm32prog,
 	   "  <size> = size of flashlayout (optional for image with STM32 header)\n"
 );
 
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-bool stm32prog_get_tee_partitions(void)
-{
-	if (stm32prog_data)
-		return stm32prog_data->tee_detected;
-
-	return false;
-}
-#endif
-
-bool stm32prog_get_fsbl_nor(void)
-{
-	if (stm32prog_data)
-		return stm32prog_data->fsbl_nor_detected;
-
-	return false;
-}
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
index c391b6c7abb..ea308b05495 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.c
@@ -63,6 +63,12 @@ static const efi_guid_t uuid_mmc[3] = {
 	ROOTFS_MMC2_UUID
 };
 
+/*
+ * GUID value defined in the FWU specification for identification
+ * of the FWU metadata partition.
+ */
+#define FWU_MDATA_UUID "8a7a84a0-8387-40f6-ab41-a8b9a5a60d23"
+
 /* FIP type partition UUID used by TF-A*/
 #define FIP_TYPE_UUID "19D5DF83-11B0-457B-BE2C-7559C13142A5"
 
@@ -208,11 +214,6 @@ static int optee_ta_invoke(struct stm32prog_data *data, int cmd, int type,
 	return rc;
 }
 
-/* partition handling routines : CONFIG_CMD_MTDPARTS */
-int mtdparts_init(void);
-int find_dev_and_part(const char *id, struct mtd_device **dev,
-		      u8 *part_num, struct part_info **part);
-
 char *stm32prog_get_error(struct stm32prog_data *data)
 {
 	static const char error_msg[] = "Unspecified";
@@ -322,7 +323,7 @@ void stm32prog_header_check(uintptr_t raw_header, struct image_header_s *header)
 	header->image_length = 0x0;
 }
 
-static u32 stm32prog_header_checksum(u32 addr, struct image_header_s *header)
+static u32 stm32prog_header_checksum(uintptr_t addr, struct image_header_s *header)
 {
 	u32 i, checksum;
 	u8 *payload;
@@ -398,7 +399,7 @@ static int parse_name(struct stm32prog_data *data,
 	if (strlen(p) < sizeof(part->name)) {
 		strcpy(part->name, p);
 	} else {
-		stm32prog_err("Layout line %d: partition name too long [%d]: %s",
+		stm32prog_err("Layout line %d: partition name too long [%zd]: %s",
 			      i, strlen(p), p);
 		result = -EINVAL;
 	}
@@ -430,8 +431,14 @@ static int parse_type(struct stm32prog_data *data,
 		}
 	} else if (!strcmp(p, "FIP")) {
 		part->part_type = PART_FIP;
+	} else if (!strcmp(p, "FWU_MDATA")) {
+		part->part_type = PART_FWU_MDATA;
+	} else if (!strcmp(p, "ENV")) {
+		part->part_type = PART_ENV;
 	} else if (!strcmp(p, "System")) {
 		part->part_type = PART_SYSTEM;
+	} else if (!strcmp(p, "ESP")) {
+		part->part_type = PART_ESP;
 	} else if (!strcmp(p, "FileSystem")) {
 		part->part_type = PART_FILESYSTEM;
 	} else if (!strcmp(p, "RawImage")) {
@@ -514,7 +521,7 @@ static int parse_offset(struct stm32prog_data *data,
 			stm32prog_err("Layout line %d: invalid part '%s'",
 				      i, p);
 	} else {
-		part->addr = simple_strtoull(p, &tail, 0);
+		part->addr = simple_strtoull(p, &tail, 10);
 		if (tail == p || *tail != '\0') {
 			stm32prog_err("Layout line %d: invalid offset '%s'",
 				      i, p);
@@ -537,7 +544,7 @@ int (* const parse[COL_NB_STM32])(struct stm32prog_data *data, int i, char *p,
 };
 
 static int parse_flash_layout(struct stm32prog_data *data,
-			      ulong addr,
+			      uintptr_t addr,
 			      ulong size)
 {
 	int column = 0, part_nb = 0, ret;
@@ -741,6 +748,7 @@ static int init_device(struct stm32prog_data *data,
 	struct mmc *mmc = NULL;
 	struct blk_desc *block_dev = NULL;
 	struct mtd_info *mtd = NULL;
+	struct mtd_info *partition;
 	char mtd_id[16];
 	int part_id;
 	int ret;
@@ -749,6 +757,7 @@ static int init_device(struct stm32prog_data *data,
 	u64 part_addr, part_size;
 	bool part_found;
 	const char *part_name;
+	u8 i;
 
 	switch (dev->target) {
 	case STM32PROG_MMC:
@@ -793,10 +802,11 @@ static int init_device(struct stm32prog_data *data,
 			stm32prog_err("unknown device type = %d", dev->target);
 			return -ENODEV;
 		}
+		/* register partitions with MTDIDS/MTDPARTS or OF fallback */
+		mtd_probe_devices();
 		get_mtd_by_target(mtd_id, dev->target, dev->dev_id);
 		log_debug("%s\n", mtd_id);
 
-		mtdparts_init();
 		mtd = get_mtd_device_nm(mtd_id);
 		if (IS_ERR(mtd)) {
 			stm32prog_err("MTD device %s not found", mtd_id);
@@ -943,25 +953,23 @@ static int init_device(struct stm32prog_data *data,
 		}
 
 		if (IS_ENABLED(CONFIG_MTD) && mtd) {
-			char mtd_part_id[32];
-			struct part_info *mtd_part;
-			struct mtd_device *mtd_dev;
-			u8 part_num;
-
-			sprintf(mtd_part_id, "%s,%d", mtd_id,
-				part->part_id - 1);
-			ret = find_dev_and_part(mtd_part_id, &mtd_dev,
-						&part_num, &mtd_part);
-			if (ret != 0) {
-				stm32prog_err("%s (0x%x): Invalid MTD partition %s",
-					      part->name, part->id,
-					      mtd_part_id);
+			i = 0;
+			list_for_each_entry(partition, &mtd->partitions, node) {
+				if ((part->part_id - 1) == i) {
+					part_found = true;
+					break;
+				}
+				i++;
+			}
+			if (part_found) {
+				part_addr = partition->offset;
+				part_size = partition->size;
+				part_name = partition->name;
+			} else {
+				stm32prog_err("%s (0x%x):Couldn't find part %d on device mtd %s",
+					      part->name, part->id, part->part_id, mtd_id);
 				return -ENODEV;
 			}
-			part_addr = mtd_part->offset;
-			part_size = mtd_part->size;
-			part_name = mtd_part->name;
-			part_found = true;
 		}
 
 		/* no partition for this device */
@@ -999,10 +1007,6 @@ static int treat_partition_list(struct stm32prog_data *data)
 		INIT_LIST_HEAD(&data->dev[j].part_list);
 	}
 
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	data->tee_detected = false;
-#endif
-	data->fsbl_nor_detected = false;
 	for (i = 0; i < data->part_nb; i++) {
 		part = &data->part_array[i];
 		part->alt_id = -1;
@@ -1047,23 +1051,6 @@ static int treat_partition_list(struct stm32prog_data *data)
 			stm32prog_err("Layout: too many device");
 			return -EINVAL;
 		}
-		switch (part->target)  {
-		case STM32PROG_NOR:
-			if (!data->fsbl_nor_detected &&
-			    !strncmp(part->name, "fsbl", 4))
-				data->fsbl_nor_detected = true;
-			/* fallthrough */
-		case STM32PROG_NAND:
-		case STM32PROG_SPI_NAND:
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-			if (!data->tee_detected &&
-			    !strncmp(part->name, "tee", 3))
-				data->tee_detected = true;
-			break;
-#endif
-		default:
-			break;
-		}
 		part->dev = &data->dev[j];
 		if (!IS_SELECT(part))
 			part->dev->full_update = false;
@@ -1090,7 +1077,6 @@ static int create_gpt_partitions(struct stm32prog_data *data)
 	if (!buf)
 		return -ENOMEM;
 
-	puts("partitions : ");
 	/* initialize the selected device */
 	for (i = 0; i < data->dev_nb; i++) {
 		/* create gpt partition support only for full update on MMC */
@@ -1098,6 +1084,7 @@ static int create_gpt_partitions(struct stm32prog_data *data)
 		    !data->dev[i].full_update)
 			continue;
 
+		printf("partitions on mmc%d: ", data->dev[i].dev_id);
 		offset = 0;
 		rootfs_found = false;
 		memset(buf, 0, buflen);
@@ -1130,10 +1117,20 @@ static int create_gpt_partitions(struct stm32prog_data *data)
 			case PART_BINARY:
 				type_str = LINUX_RESERVED_UUID;
 				break;
+			case PART_ENV:
+				type_str = "u-boot-env";
+				break;
 			case PART_FIP:
 				type_str = FIP_TYPE_UUID;
 				break;
-			default:
+			case PART_FWU_MDATA:
+				type_str = FWU_MDATA_UUID;
+				break;
+			case PART_ESP:
+				/* EFI System Partition */
+				type_str = "system";
+				break;
+			default: /* PART_FILESYSTEM or PART_SYSTEM for distro */
 				type_str = "linux";
 				break;
 			}
@@ -1197,8 +1194,8 @@ static int create_gpt_partitions(struct stm32prog_data *data)
 		sprintf(buf, "part list mmc %d", data->dev[i].dev_id);
 		run_command(buf, 0);
 #endif
+		puts("done\n");
 	}
-	puts("done\n");
 
 #ifdef DEBUG
 	run_command("mtd list", 0);
@@ -1342,10 +1339,22 @@ static int dfu_init_entities(struct stm32prog_data *data)
 	struct stm32prog_part_t *part;
 	struct dfu_entity *dfu;
 	int alt_nb;
+	u32 otp_size = 0;
 
 	alt_nb = 1; /* number of virtual = CMD*/
-	if (IS_ENABLED(CONFIG_CMD_STM32PROG_OTP))
-		alt_nb++; /* OTP*/
+
+	if (IS_ENABLED(CONFIG_CMD_STM32PROG_OTP)) {
+		/* OTP_SIZE_SMC = 0 if SMC is not supported */
+		otp_size = OTP_SIZE_SMC;
+		/* check if PTA BSEC is supported */
+		ret = optee_ta_open(data);
+		log_debug("optee_ta_open(PTA_NVMEM) result %d\n", ret);
+		if (!ret && data->tee)
+			otp_size = OTP_SIZE_TA;
+		if (otp_size)
+			alt_nb++; /* OTP*/
+	}
+
 	if (CONFIG_IS_ENABLED(DM_PMIC))
 		alt_nb++; /* PMIC NVMEM*/
 
@@ -1363,6 +1372,7 @@ static int dfu_init_entities(struct stm32prog_data *data)
 	puts("DFU alt info setting: ");
 	if (data->part_nb) {
 		alt_id = 0;
+		ret = 0;
 		for (phase = 1;
 		     (phase <= PHASE_LAST_USER) &&
 		     (alt_id < alt_nb) && !ret;
@@ -1388,7 +1398,7 @@ static int dfu_init_entities(struct stm32prog_data *data)
 		char buf[ALT_BUF_LEN];
 
 		sprintf(buf, "@FlashLayout/0x%02x/1*256Ke ram %x 40000",
-			PHASE_FLASHLAYOUT, STM32_DDR_BASE);
+			PHASE_FLASHLAYOUT, CONFIG_SYS_LOAD_ADDR);
 		ret = dfu_alt_add(dfu, "ram", NULL, buf);
 		log_debug("dfu_alt_add(ram, NULL,%s) result %d\n", buf, ret);
 	}
@@ -1396,12 +1406,8 @@ static int dfu_init_entities(struct stm32prog_data *data)
 	if (!ret)
 		ret = stm32prog_alt_add_virt(dfu, "virtual", PHASE_CMD, CMD_SIZE);
 
-	if (!ret && IS_ENABLED(CONFIG_CMD_STM32PROG_OTP)) {
-		ret = optee_ta_open(data);
-		log_debug("optee_ta result %d\n", ret);
-		ret = stm32prog_alt_add_virt(dfu, "OTP", PHASE_OTP,
-					     data->tee ? OTP_SIZE_TA : OTP_SIZE_SMC);
-	}
+	if (!ret && IS_ENABLED(CONFIG_CMD_STM32PROG_OTP) && otp_size)
+		ret = stm32prog_alt_add_virt(dfu, "OTP", PHASE_OTP, otp_size);
 
 	if (!ret && CONFIG_IS_ENABLED(DM_PMIC))
 		ret = stm32prog_alt_add_virt(dfu, "PMIC", PHASE_PMIC, PMIC_SIZE);
@@ -1430,8 +1436,11 @@ int stm32prog_otp_write(struct stm32prog_data *data, u32 offset, u8 *buffer,
 
 	if (!data->otp_part) {
 		data->otp_part = memalign(CONFIG_SYS_CACHELINE_SIZE, otp_size);
-		if (!data->otp_part)
+		if (!data->otp_part) {
+			stm32prog_err("OTP write issue %d", -ENOMEM);
+
 			return -ENOMEM;
+		}
 	}
 
 	if (!offset)
@@ -1440,7 +1449,7 @@ int stm32prog_otp_write(struct stm32prog_data *data, u32 offset, u8 *buffer,
 	if (offset + *size > otp_size)
 		*size = otp_size - offset;
 
-	memcpy((void *)((u32)data->otp_part + offset), buffer, *size);
+	memcpy((void *)((uintptr_t)data->otp_part + offset), buffer, *size);
 
 	return 0;
 }
@@ -1479,7 +1488,7 @@ int stm32prog_otp_read(struct stm32prog_data *data, u32 offset, u8 *buffer,
 						 data->otp_part, OTP_SIZE_TA);
 		else if (IS_ENABLED(CONFIG_ARM_SMCCC))
 			result = stm32_smc_exec(STM32_SMC_BSEC, STM32_SMC_READ_ALL,
-						(u32)data->otp_part, 0);
+						(unsigned long)data->otp_part, 0);
 		if (result)
 			goto end_otp_read;
 	}
@@ -1491,9 +1500,11 @@ int stm32prog_otp_read(struct stm32prog_data *data, u32 offset, u8 *buffer,
 
 	if (offset + *size > otp_size)
 		*size = otp_size - offset;
-	memcpy(buffer, (void *)((u32)data->otp_part + offset), *size);
+	memcpy(buffer, (void *)((uintptr_t)data->otp_part + offset), *size);
 
 end_otp_read:
+	if (result)
+		stm32prog_err("OTP read issue %d", result);
 	log_debug("%s: result %i\n", __func__, result);
 
 	return result;
@@ -1521,7 +1532,7 @@ int stm32prog_otp_start(struct stm32prog_data *data)
 					 data->otp_part, OTP_SIZE_TA);
 	} else if (IS_ENABLED(CONFIG_ARM_SMCCC)) {
 		arm_smccc_smc(STM32_SMC_BSEC, STM32_SMC_WRITE_ALL,
-			      (u32)data->otp_part, 0, 0, 0, 0, 0, &res);
+			      (uintptr_t)data->otp_part, 0, 0, 0, 0, 0, &res);
 
 		if (!res.a0) {
 			switch (res.a1) {
@@ -1547,6 +1558,8 @@ int stm32prog_otp_start(struct stm32prog_data *data)
 
 	free(data->otp_part);
 	data->otp_part = NULL;
+	if (result)
+		stm32prog_err("OTP write issue %d", result);
 	log_debug("%s: result %i\n", __func__, result);
 
 	return result;
@@ -1699,15 +1712,15 @@ static void stm32prog_end_phase(struct stm32prog_data *data, u64 offset)
 {
 	if (data->phase == PHASE_FLASHLAYOUT) {
 #if defined(CONFIG_LEGACY_IMAGE_FORMAT)
-		if (genimg_get_format((void *)STM32_DDR_BASE) == IMAGE_FORMAT_LEGACY) {
-			data->script = STM32_DDR_BASE;
+		if (genimg_get_format((void *)CONFIG_SYS_LOAD_ADDR) == IMAGE_FORMAT_LEGACY) {
+			data->script = CONFIG_SYS_LOAD_ADDR;
 			data->phase = PHASE_END;
 			log_notice("U-Boot script received\n");
 			return;
 		}
 #endif
 		log_notice("\nFlashLayout received, size = %lld\n", offset);
-		if (parse_flash_layout(data, STM32_DDR_BASE, offset))
+		if (parse_flash_layout(data, CONFIG_SYS_LOAD_ADDR, offset))
 			stm32prog_err("Layout: invalid FlashLayout");
 		return;
 	}
@@ -1884,6 +1897,10 @@ static void stm32prog_devices_init(struct stm32prog_data *data)
 	if (ret)
 		goto error;
 
+	/* empty flashlayout */
+	if (!data->dev_nb)
+		return;
+
 	/* initialize the selected device */
 	for (i = 0; i < data->dev_nb; i++) {
 		ret = init_device(data, &data->dev[i]);
@@ -1947,7 +1964,7 @@ int stm32prog_dfu_init(struct stm32prog_data *data)
 	return dfu_init_entities(data);
 }
 
-int stm32prog_init(struct stm32prog_data *data, ulong addr, ulong size)
+int stm32prog_init(struct stm32prog_data *data, uintptr_t addr, ulong size)
 {
 	memset(data, 0x0, sizeof(*data));
 	data->read_phase = PHASE_RESET;
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
index ac300768ca0..0351d25e5d8 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog.h
@@ -20,7 +20,12 @@
 #define DEFAULT_ADDRESS		0xFFFFFFFF
 
 #define CMD_SIZE		512
+/* SMC is only supported in SPMIN for STM32MP15X */
+#ifdef CONFIG_STM32MP15X
 #define OTP_SIZE_SMC		1024
+#else
+#define OTP_SIZE_SMC		0
+#endif
 #define OTP_SIZE_TA		776
 #define PMIC_SIZE		8
 
@@ -91,12 +96,20 @@ struct stm32_header_v2 {
 	u8 extension_padding[376];
 };
 
-/* partition type in flashlayout file */
+/*
+ * partition type in flashlayout file
+ * SYSTEM = linux partition, bootable
+ * FILESYSTEM = linux partition
+ * ESP = EFI system partition
+ */
 enum stm32prog_part_type {
 	PART_BINARY,
 	PART_FIP,
+	PART_FWU_MDATA,
+	PART_ENV,
 	PART_SYSTEM,
 	PART_FILESYSTEM,
+	PART_ESP,
 	RAW_IMAGE,
 };
 
@@ -144,17 +157,13 @@ struct stm32prog_data {
 	struct stm32prog_dev_t	dev[STM32PROG_MAX_DEV];	/* array of device */
 	int			part_nb;	/* nb of partition */
 	struct stm32prog_part_t	*part_array;	/* array of partition */
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-	bool			tee_detected;
-#endif
-	bool			fsbl_nor_detected;
 
 	/* command internal information */
 	unsigned int		phase;
 	u32			offset;
 	char			error[255];
 	struct stm32prog_part_t	*cur_part;
-	u32			*otp_part;
+	void			*otp_part;
 	u8			pmic_part[PMIC_SIZE];
 
 	/* SERIAL information */
@@ -165,12 +174,12 @@ struct stm32prog_data {
 	u8	read_phase;
 
 	/* bootm information */
-	u32	uimage;
-	u32	dtb;
-	u32	initrd;
-	u32	initrd_size;
+	uintptr_t	uimage;
+	uintptr_t	dtb;
+	uintptr_t	initrd;
+	size_t		initrd_size;
 
-	u32	script;
+	uintptr_t	script;
 
 	/* OPTEE PTA NVMEM */
 	struct udevice *tee;
@@ -209,7 +218,7 @@ char *stm32prog_get_error(struct stm32prog_data *data);
 	}
 
 /* Main function */
-int stm32prog_init(struct stm32prog_data *data, ulong addr, ulong size);
+int stm32prog_init(struct stm32prog_data *data, uintptr_t addr, ulong size);
 void stm32prog_clean(struct stm32prog_data *data);
 
 #ifdef CONFIG_CMD_STM32PROG_SERIAL
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
index 2932eae7578..9f2ab2b625c 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_serial.c
@@ -300,7 +300,7 @@ static void stm32prog_serial_putc(u8 w_byte)
 }
 
 /* Helper function ************************************************/
-static u8 stm32prog_start(struct stm32prog_data *data, u32 address)
+static u8 stm32prog_start(struct stm32prog_data *data, uintptr_t address)
 {
 	u8 ret = 0;
 	struct dfu_entity *dfu_entity;
@@ -353,7 +353,7 @@ static u8 stm32prog_start(struct stm32prog_data *data, u32 address)
 	} else {
 		void (*entry)(void) = (void *)address;
 
-		printf("## Starting application at 0x%x ...\n", address);
+		printf("## Starting application at 0x%p ...\n", (void *)address);
 		(*entry)();
 		printf("## Application terminated\n");
 		ret = -ENOEXEC;
@@ -368,9 +368,9 @@ static u8 stm32prog_start(struct stm32prog_data *data, u32 address)
  * @tmp_xor:		Current xor value to update
  * Return: The address area
  */
-static u32 get_address(u8 *tmp_xor)
+static uintptr_t get_address(u8 *tmp_xor)
 {
-	u32 address = 0x0;
+	uintptr_t address = 0x0;
 	u8 data;
 
 	data = stm32prog_serial_getc();
@@ -462,7 +462,7 @@ static void get_phase_command(struct stm32prog_data *data)
 		length = strlen(err_msg);
 	}
 	if (phase == PHASE_FLASHLAYOUT)
-		destination = STM32_DDR_BASE;
+		destination = CONFIG_SYS_LOAD_ADDR;
 
 	stm32prog_serial_putc(length + 5);           /* Total length */
 	stm32prog_serial_putc(phase & 0xFF);         /* partition ID */
@@ -487,7 +487,7 @@ static void get_phase_command(struct stm32prog_data *data)
  */
 static void read_memory_command(struct stm32prog_data *data)
 {
-	u32 address = 0x0;
+	uintptr_t address = 0x0;
 	u8 rcv_data = 0x0, tmp_xor = 0x0;
 	u32 counter = 0x0;
 
@@ -532,7 +532,7 @@ static void read_memory_command(struct stm32prog_data *data)
  */
 static void start_command(struct stm32prog_data *data)
 {
-	u32 address = 0;
+	uintptr_t address = 0;
 	u8 tmp_xor = 0x0;
 	u8 ret, rcv_data;
 
@@ -546,8 +546,7 @@ static void start_command(struct stm32prog_data *data)
 		return;
 	}
 	/* validate partition */
-	ret = stm32prog_start(data,
-			      address);
+	ret = stm32prog_start(data, address);
 
 	if (ret)
 		stm32prog_serial_result(ABORT_BYTE);
diff --git a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_usb.c b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_usb.c
index a8b57c4d8f0..be38ff239b2 100644
--- a/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_usb.c
+++ b/arch/arm/mach-stm32mp/cmd_stm32prog/stm32prog_usb.c
@@ -41,7 +41,7 @@ static int stm32prog_set_phase(struct stm32prog_data *data, u8 phase,
 static int stm32prog_cmd_write(u64 offset, void *buf, long *len)
 {
 	u8 phase;
-	u32 address;
+	uintptr_t address;
 	u8 *pt = buf;
 	void (*entry)(void);
 	int ret;
@@ -58,7 +58,7 @@ static int stm32prog_cmd_write(u64 offset, void *buf, long *len)
 	address = (pt[1] << 24) | (pt[2] << 16) | (pt[3] << 8) | pt[4];
 	if (phase == PHASE_RESET) {
 		entry = (void *)address;
-		printf("## Starting application at 0x%x ...\n", address);
+		printf("## Starting application at 0x%p ...\n", entry);
 		(*entry)();
 		printf("## Application terminated\n");
 		return 0;
@@ -90,7 +90,7 @@ static int stm32prog_cmd_read(u64 offset, void *buf, long *len)
 	}
 	phase = stm32prog_data->phase;
 	if (phase == PHASE_FLASHLAYOUT)
-		destination = STM32_DDR_BASE;
+		destination = CONFIG_SYS_LOAD_ADDR;
 	dfu_offset = stm32prog_data->offset;
 
 	/* mandatory header, size = PHASE_MIN_SIZE */
diff --git a/arch/arm/mach-stm32mp/etzpc.c b/arch/arm/mach-stm32mp/etzpc.c
new file mode 100644
index 00000000000..25b8e518bb5
--- /dev/null
+++ b/arch/arm/mach-stm32mp/etzpc.c
@@ -0,0 +1,205 @@
+// SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#define LOG_CATEGORY UCLASS_SIMPLE_BUS
+
+#include <common.h>
+#include <dm.h>
+#include <asm/io.h>
+#include <dm/device.h>
+#include <dm/device_compat.h>
+#include <dm/lists.h>
+#include <linux/bitfield.h>
+#include <mach/etzpc.h>
+
+/* ETZPC peripheral as firewall bus */
+/* ETZPC registers */
+#define ETZPC_DECPROT			0x10
+
+/* ETZPC miscellaneous */
+#define ETZPC_PROT_MASK			GENMASK(1, 0)
+#define ETZPC_PROT_A7NS			0x3
+#define ETZPC_DECPROT_SHIFT		1
+
+#define IDS_PER_DECPROT_REGS		16
+#define STM32MP15_ETZPC_ENTRIES		96
+#define STM32MP13_ETZPC_ENTRIES		64
+
+/*
+ * struct stm32_sys_bus_match_data: Match data for ETZPC device
+ *
+ * @max_entries: Number of securable peripherals in ETZPC
+ */
+struct stm32_sys_bus_match_data {
+	unsigned int max_entries;
+};
+
+/*
+ * struct stm32_etzpc_plat: Information about ETZPC device
+ *
+ * @base: Base address of ETZPC
+ */
+struct stm32_etzpc_plat {
+	void *base;
+};
+
+static int etzpc_parse_feature_domain(ofnode node, struct ofnode_phandle_args *args)
+{
+	int ret;
+
+	ret = ofnode_parse_phandle_with_args(node, "feature-domains",
+					     "#feature-domain-cells", 0,
+					     0, args);
+	if (ret) {
+		log_debug("failed to parse feature-domains (%d)\n", ret);
+		return ret;
+	}
+
+	if (args->args_count != 1) {
+		log_debug("invalid domain args_count: %d\n", args->args_count);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int etzpc_check_access(void *base, u32 id)
+{
+	u32 reg_offset, offset, sec_val;
+
+	/* Check access configuration, 16 peripherals per register */
+	reg_offset = ETZPC_DECPROT + 0x4 * (id / IDS_PER_DECPROT_REGS);
+	offset = (id % IDS_PER_DECPROT_REGS) << ETZPC_DECPROT_SHIFT;
+
+	/* Verify peripheral is non-secure and attributed to cortex A7 */
+	sec_val = (readl(base + reg_offset) >> offset) & ETZPC_PROT_MASK;
+	if (sec_val != ETZPC_PROT_A7NS) {
+		log_debug("Invalid bus configuration: reg_offset %#x, value %d\n",
+			  reg_offset, sec_val);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+int stm32_etzpc_check_access_by_id(ofnode device_node, u32 id)
+{
+	struct stm32_sys_bus_match_data *pconf;
+	struct stm32_etzpc_plat *plat;
+	struct ofnode_phandle_args args;
+	struct udevice *dev;
+	int err;
+
+	err = etzpc_parse_feature_domain(device_node, &args);
+	if (err)
+		return err;
+
+	if (id == -1U)
+		id = args.args[0];
+
+	err = uclass_get_device_by_ofnode(UCLASS_NOP, args.node, &dev);
+	if (err || dev->driver != DM_DRIVER_GET(stm32_etzpc)) {
+		log_err("No device found\n");
+		return -EINVAL;
+	}
+
+	plat = dev_get_plat(dev);
+	pconf = (struct stm32_sys_bus_match_data *)dev_get_driver_data(dev);
+
+	if (id >= pconf->max_entries) {
+		dev_err(dev, "Invalid sys bus ID for %s\n", ofnode_get_name(device_node));
+		return -EINVAL;
+	}
+
+	return etzpc_check_access(plat->base, id);
+}
+
+int stm32_etzpc_check_access(ofnode device_node)
+{
+	return stm32_etzpc_check_access_by_id(device_node, -1U);
+}
+
+static int stm32_etzpc_bind(struct udevice *dev)
+{
+	struct stm32_etzpc_plat *plat = dev_get_plat(dev);
+	struct stm32_sys_bus_match_data *pconf;
+	struct ofnode_phandle_args args;
+	int ret = 0, err = 0;
+	ofnode node, parent;
+
+	plat->base = dev_read_addr_ptr(dev);
+	if (!plat->base) {
+		dev_err(dev, "can't get registers base address\n");
+		return -ENOENT;
+	}
+
+	pconf = (struct stm32_sys_bus_match_data *)dev_get_driver_data(dev);
+	parent = dev_ofnode(dev);
+	for (node = ofnode_first_subnode(parent);
+	     ofnode_valid(node);
+	     node = ofnode_next_subnode(node)) {
+		const char *node_name = ofnode_get_name(node);
+
+		if (!ofnode_is_enabled(node))
+			continue;
+
+		err = etzpc_parse_feature_domain(node, &args);
+		if (err) {
+			dev_err(dev, "%s failed to parse child on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		if (!ofnode_equal(args.node, parent)) {
+			dev_err(dev, "%s phandle to %s\n",
+				node_name, ofnode_get_name(args.node));
+			continue;
+		}
+
+		if (args.args[0] >= pconf->max_entries) {
+			dev_err(dev, "Invalid sys bus ID for %s\n", node_name);
+			return -EINVAL;
+		}
+
+		err = etzpc_check_access(plat->base, args.args[0]);
+		if (err) {
+			dev_info(dev, "%s not allowed on bus (%d)\n", node_name, err);
+			continue;
+		}
+
+		err = lists_bind_fdt(dev, node, NULL, NULL,
+				     gd->flags & GD_FLG_RELOC ? false : true);
+		if (err) {
+			ret = err;
+			dev_err(dev, "%s failed to bind on bus (%d)\n", node_name, ret);
+		}
+	}
+
+	if (ret)
+		dev_err(dev, "Some child failed to bind (%d)\n", ret);
+
+	return ret;
+}
+
+static const struct stm32_sys_bus_match_data stm32mp15_sys_bus_data = {
+	.max_entries = STM32MP15_ETZPC_ENTRIES,
+};
+
+static const struct stm32_sys_bus_match_data stm32mp13_sys_bus_data = {
+	.max_entries = STM32MP13_ETZPC_ENTRIES,
+};
+
+static const struct udevice_id stm32_etzpc_ids[] = {
+	{ .compatible = "st,stm32mp13-sys-bus", .data = (ulong)&stm32mp13_sys_bus_data },
+	{ .compatible = "st,stm32mp15-sys-bus", .data = (ulong)&stm32mp15_sys_bus_data },
+	{},
+};
+
+U_BOOT_DRIVER(stm32_etzpc) = {
+	.name = "stm32_etzpc",
+	.id = UCLASS_NOP,
+	.of_match = stm32_etzpc_ids,
+	.bind = stm32_etzpc_bind,
+	.plat_auto = sizeof(struct stm32_etzpc_plat),
+};
diff --git a/arch/arm/mach-stm32mp/fdt.c b/arch/arm/mach-stm32mp/fdt.c
index 3b4c05d7451..7282cb34f24 100644
--- a/arch/arm/mach-stm32mp/fdt.c
+++ b/arch/arm/mach-stm32mp/fdt.c
@@ -14,20 +14,6 @@
 #include <dt-bindings/pinctrl/stm32-pinfunc.h>
 #include <linux/io.h>
 
-#define ETZPC_DECPROT(n)	(STM32_ETZPC_BASE + 0x10 + 4 * (n))
-#define ETZPC_DECPROT_NB	6
-
-#define DECPROT_MASK		0x03
-#define NB_PROT_PER_REG		0x10
-#define DECPROT_NB_BITS		2
-
-#define DECPROT_SECURED		0x00
-#define DECPROT_WRITE_SECURE	0x01
-#define DECPROT_MCU_ISOLATION	0x02
-#define DECPROT_NON_SECURED	0x03
-
-#define ETZPC_RESERVED		0xffffffff
-
 #define STM32MP13_FDCAN_BASE	0x4400F000
 #define STM32MP13_ADC1_BASE	0x48003000
 #define STM32MP13_TSC_BASE	0x5000B000
@@ -42,204 +28,6 @@
 #define STM32MP15_GPU_BASE	0x59000000
 #define STM32MP15_DSI_BASE	0x5a000000
 
-static const u32 stm32mp13_ip_addr[] = {
-	0x50025000,		/* 0 VREFBUF APB3 */
-	0x50021000,		/* 1 LPTIM2 APB3 */
-	0x50022000,		/* 2 LPTIM3 APB3 */
-	STM32MP13_LTDC_BASE,	/* 3 LTDC APB4 */
-	STM32MP13_DCMIPP_BASE,	/* 4 DCMIPP APB4 */
-	0x5A006000,		/* 5 USBPHYCTRL APB4 */
-	0x5A003000,		/* 6 DDRCTRLPHY APB4 */
-	ETZPC_RESERVED,		/* 7 Reserved*/
-	ETZPC_RESERVED,		/* 8 Reserved*/
-	ETZPC_RESERVED,		/* 9 Reserved*/
-	0x5C006000,		/* 10 TZC APB5 */
-	0x58001000,		/* 11 MCE APB5 */
-	0x5C000000,		/* 12 IWDG1 APB5 */
-	0x5C008000,		/* 13 STGENC APB5 */
-	ETZPC_RESERVED,		/* 14 Reserved*/
-	ETZPC_RESERVED,		/* 15 Reserved*/
-	0x4C000000,		/* 16 USART1 APB6 */
-	0x4C001000,		/* 17 USART2 APB6 */
-	0x4C002000,		/* 18 SPI4 APB6 */
-	0x4C003000,		/* 19 SPI5 APB6 */
-	0x4C004000,		/* 20 I2C3 APB6 */
-	0x4C005000,		/* 21 I2C4 APB6 */
-	0x4C006000,		/* 22 I2C5 APB6 */
-	0x4C007000,		/* 23 TIM12 APB6 */
-	0x4C008000,		/* 24 TIM13 APB6 */
-	0x4C009000,		/* 25 TIM14 APB6 */
-	0x4C00A000,		/* 26 TIM15 APB6 */
-	0x4C00B000,		/* 27 TIM16 APB6 */
-	0x4C00C000,		/* 28 TIM17 APB6 */
-	ETZPC_RESERVED,		/* 29 Reserved*/
-	ETZPC_RESERVED,		/* 30 Reserved*/
-	ETZPC_RESERVED,		/* 31 Reserved*/
-	STM32MP13_ADC1_BASE,	/* 32 ADC1 AHB2 */
-	0x48004000,		/* 33 ADC2 AHB2 */
-	0x49000000,		/* 34 OTG AHB2 */
-	ETZPC_RESERVED,		/* 35 Reserved*/
-	ETZPC_RESERVED,		/* 36 Reserved*/
-	STM32MP13_TSC_BASE,	/* 37 TSC AHB4 */
-	ETZPC_RESERVED,		/* 38 Reserved*/
-	ETZPC_RESERVED,		/* 39 Reserved*/
-	0x54004000,		/* 40 RNG AHB5 */
-	0x54003000,		/* 41 HASH AHB5 */
-	STM32MP13_CRYP_BASE,	/* 42 CRYPT AHB5 */
-	0x54005000,		/* 43 SAES AHB5 */
-	0x54006000,		/* 44 PKA AHB5 */
-	0x54000000,		/* 45 BKPSRAM AHB5 */
-	ETZPC_RESERVED,		/* 46 Reserved*/
-	ETZPC_RESERVED,		/* 47 Reserved*/
-	0x5800A000,		/* 48 ETH1 AHB6 */
-	STM32MP13_ETH2_BASE,	/* 49 ETH2 AHB6 */
-	0x58005000,		/* 50 SDMMC1 AHB6 */
-	0x58007000,		/* 51 SDMMC2 AHB6 */
-	ETZPC_RESERVED,		/* 52 Reserved*/
-	ETZPC_RESERVED,		/* 53 Reserved*/
-	0x58002000,		/* 54 FMC AHB6 */
-	0x58003000,		/* 55 QSPI AHB6 */
-	ETZPC_RESERVED,		/* 56 Reserved*/
-	ETZPC_RESERVED,		/* 57 Reserved*/
-	ETZPC_RESERVED,		/* 58 Reserved*/
-	ETZPC_RESERVED,		/* 59 Reserved*/
-	0x30000000,		/* 60 SRAM1 MLAHB */
-	0x30004000,		/* 61 SRAM2 MLAHB */
-	0x30006000,		/* 62 SRAM3 MLAHB */
-	ETZPC_RESERVED,		/* 63 Reserved*/
-	ETZPC_RESERVED,		/* 64 Reserved*/
-	ETZPC_RESERVED,		/* 65 Reserved*/
-	ETZPC_RESERVED,		/* 66 Reserved*/
-	ETZPC_RESERVED,		/* 67 Reserved*/
-	ETZPC_RESERVED,		/* 68 Reserved*/
-	ETZPC_RESERVED,		/* 69 Reserved*/
-	ETZPC_RESERVED,		/* 70 Reserved*/
-	ETZPC_RESERVED,		/* 71 Reserved*/
-	ETZPC_RESERVED,		/* 72 Reserved*/
-	ETZPC_RESERVED,		/* 73 Reserved*/
-	ETZPC_RESERVED,		/* 74 Reserved*/
-	ETZPC_RESERVED,		/* 75 Reserved*/
-	ETZPC_RESERVED,		/* 76 Reserved*/
-	ETZPC_RESERVED,		/* 77 Reserved*/
-	ETZPC_RESERVED,		/* 78 Reserved*/
-	ETZPC_RESERVED,		/* 79 Reserved*/
-	ETZPC_RESERVED,		/* 80 Reserved*/
-	ETZPC_RESERVED,		/* 81 Reserved*/
-	ETZPC_RESERVED,		/* 82 Reserved*/
-	ETZPC_RESERVED,		/* 83 Reserved*/
-	ETZPC_RESERVED,		/* 84 Reserved*/
-	ETZPC_RESERVED,		/* 85 Reserved*/
-	ETZPC_RESERVED,		/* 86 Reserved*/
-	ETZPC_RESERVED,		/* 87 Reserved*/
-	ETZPC_RESERVED,		/* 88 Reserved*/
-	ETZPC_RESERVED,		/* 89 Reserved*/
-	ETZPC_RESERVED,		/* 90 Reserved*/
-	ETZPC_RESERVED,		/* 91 Reserved*/
-	ETZPC_RESERVED,		/* 92 Reserved*/
-	ETZPC_RESERVED,		/* 93 Reserved*/
-	ETZPC_RESERVED,		/* 94 Reserved*/
-	ETZPC_RESERVED,		/* 95 Reserved*/
-};
-
-static const u32 stm32mp15_ip_addr[] = {
-	0x5c008000,	/* 00 stgenc */
-	0x54000000,	/* 01 bkpsram */
-	0x5c003000,	/* 02 iwdg1 */
-	0x5c000000,	/* 03 usart1 */
-	0x5c001000,	/* 04 spi6 */
-	0x5c002000,	/* 05 i2c4 */
-	ETZPC_RESERVED,	/* 06 reserved */
-	0x54003000,	/* 07 rng1 */
-	0x54002000,	/* 08 hash1 */
-	STM32MP15_CRYP1_BASE,	/* 09 cryp1 */
-	0x5a003000,	/* 0A ddrctrl */
-	0x5a004000,	/* 0B ddrphyc */
-	0x5c009000,	/* 0C i2c6 */
-	ETZPC_RESERVED,	/* 0D reserved */
-	ETZPC_RESERVED,	/* 0E reserved */
-	ETZPC_RESERVED,	/* 0F reserved */
-	0x40000000,	/* 10 tim2 */
-	0x40001000,	/* 11 tim3 */
-	0x40002000,	/* 12 tim4 */
-	0x40003000,	/* 13 tim5 */
-	0x40004000,	/* 14 tim6 */
-	0x40005000,	/* 15 tim7 */
-	0x40006000,	/* 16 tim12 */
-	0x40007000,	/* 17 tim13 */
-	0x40008000,	/* 18 tim14 */
-	0x40009000,	/* 19 lptim1 */
-	0x4000a000,	/* 1A wwdg1 */
-	0x4000b000,	/* 1B spi2 */
-	0x4000c000,	/* 1C spi3 */
-	0x4000d000,	/* 1D spdifrx */
-	0x4000e000,	/* 1E usart2 */
-	0x4000f000,	/* 1F usart3 */
-	0x40010000,	/* 20 uart4 */
-	0x40011000,	/* 21 uart5 */
-	0x40012000,	/* 22 i2c1 */
-	0x40013000,	/* 23 i2c2 */
-	0x40014000,	/* 24 i2c3 */
-	0x40015000,	/* 25 i2c5 */
-	0x40016000,	/* 26 cec */
-	0x40017000,	/* 27 dac */
-	0x40018000,	/* 28 uart7 */
-	0x40019000,	/* 29 uart8 */
-	ETZPC_RESERVED,	/* 2A reserved */
-	ETZPC_RESERVED,	/* 2B reserved */
-	0x4001c000,	/* 2C mdios */
-	ETZPC_RESERVED,	/* 2D reserved */
-	ETZPC_RESERVED,	/* 2E reserved */
-	ETZPC_RESERVED,	/* 2F reserved */
-	0x44000000,	/* 30 tim1 */
-	0x44001000,	/* 31 tim8 */
-	ETZPC_RESERVED,	/* 32 reserved */
-	0x44003000,	/* 33 usart6 */
-	0x44004000,	/* 34 spi1 */
-	0x44005000,	/* 35 spi4 */
-	0x44006000,	/* 36 tim15 */
-	0x44007000,	/* 37 tim16 */
-	0x44008000,	/* 38 tim17 */
-	0x44009000,	/* 39 spi5 */
-	0x4400a000,	/* 3A sai1 */
-	0x4400b000,	/* 3B sai2 */
-	0x4400c000,	/* 3C sai3 */
-	0x4400d000,	/* 3D dfsdm */
-	STM32MP15_FDCAN_BASE,	/* 3E tt_fdcan */
-	ETZPC_RESERVED,	/* 3F reserved */
-	0x50021000,	/* 40 lptim2 */
-	0x50022000,	/* 41 lptim3 */
-	0x50023000,	/* 42 lptim4 */
-	0x50024000,	/* 43 lptim5 */
-	0x50027000,	/* 44 sai4 */
-	0x50025000,	/* 45 vrefbuf */
-	0x4c006000,	/* 46 dcmi */
-	0x4c004000,	/* 47 crc2 */
-	0x48003000,	/* 48 adc */
-	0x4c002000,	/* 49 hash2 */
-	0x4c003000,	/* 4A rng2 */
-	STM32MP15_CRYP2_BASE,	/* 4B cryp2 */
-	ETZPC_RESERVED,	/* 4C reserved */
-	ETZPC_RESERVED,	/* 4D reserved */
-	ETZPC_RESERVED,	/* 4E reserved */
-	ETZPC_RESERVED,	/* 4F reserved */
-	ETZPC_RESERVED,	/* 50 sram1 */
-	ETZPC_RESERVED,	/* 51 sram2 */
-	ETZPC_RESERVED,	/* 52 sram3 */
-	ETZPC_RESERVED,	/* 53 sram4 */
-	ETZPC_RESERVED,	/* 54 retram */
-	0x49000000,	/* 55 otg */
-	0x48004000,	/* 56 sdmmc3 */
-	0x48005000,	/* 57 dlybsd3 */
-	0x48000000,	/* 58 dma1 */
-	0x48001000,	/* 59 dma2 */
-	0x48002000,	/* 5A dmamux */
-	0x58002000,	/* 5B fmc */
-	0x58003000,	/* 5C qspi */
-	0x58004000,	/* 5D dlybq */
-	0x5800a000,	/* 5E eth */
-	ETZPC_RESERVED,	/* 5F reserved */
-};
-
 /* fdt helper */
 static bool fdt_disable_subnode_by_address(void *fdt, int offset, u32 addr)
 {
@@ -263,46 +51,6 @@ static bool fdt_disable_subnode_by_address(void *fdt, int offset, u32 addr)
 	return false;
 }
 
-static int stm32_fdt_fixup_etzpc(void *fdt, int soc_node)
-{
-	const u32 *array;
-	int array_size, i;
-	int offset, shift;
-	u32 addr, status, decprot[ETZPC_DECPROT_NB];
-
-	if (IS_ENABLED(CONFIG_STM32MP13x)) {
-		array = stm32mp13_ip_addr;
-		array_size = ARRAY_SIZE(stm32mp13_ip_addr);
-	}
-
-	if (IS_ENABLED(CONFIG_STM32MP15x)) {
-		array = stm32mp15_ip_addr;
-		array_size = ARRAY_SIZE(stm32mp15_ip_addr);
-	}
-
-	for (i = 0; i < ETZPC_DECPROT_NB; i++)
-		decprot[i] = readl(ETZPC_DECPROT(i));
-
-	for (i = 0; i < array_size; i++) {
-		offset = i / NB_PROT_PER_REG;
-		shift = (i % NB_PROT_PER_REG) * DECPROT_NB_BITS;
-		status = (decprot[offset] >> shift) & DECPROT_MASK;
-		addr = array[i];
-
-		log_debug("ETZPC: 0x%08x decprot %d=%d\n", addr, i, status);
-
-		if (addr == ETZPC_RESERVED ||
-		    status == DECPROT_NON_SECURED)
-			continue;
-
-		if (fdt_disable_subnode_by_address(fdt, soc_node, addr))
-			log_notice("ETZPC: 0x%08x node disabled, decprot %d=%d\n",
-				   addr, i, status);
-	}
-
-	return 0;
-}
-
 /* deactivate all the cpu except core 0 */
 static void stm32_fdt_fixup_cpu(void *blob, char *name)
 {
@@ -481,20 +229,14 @@ int ft_system_setup(void *blob, struct bd_info *bd)
 	if (soc < 0)
 		return soc;
 
-	if (CONFIG_IS_ENABLED(STM32_ETZPC)) {
-		ret = stm32_fdt_fixup_etzpc(blob, soc);
-		if (ret)
-			return ret;
-	}
-
 	/* MPUs Part Numbers and name*/
 	cpu = get_cpu_type();
 	get_soc_name(name);
 
-	if (IS_ENABLED(CONFIG_STM32MP13x))
+	if (IS_ENABLED(CONFIG_STM32MP13X))
 		stm32mp13_fdt_fixup(blob, soc, cpu, name);
 
-	if (IS_ENABLED(CONFIG_STM32MP15x)) {
+	if (IS_ENABLED(CONFIG_STM32MP15X)) {
 		stm32mp15_fdt_fixup(blob, soc, cpu, name);
 
 		/*
@@ -502,10 +244,10 @@ int ft_system_setup(void *blob, struct bd_info *bd)
 		 *       copied from U-Boot device tree by optee_copy_fdt_nodes
 		 *       when OP-TEE is not detected (probe failed)
 		 * these OP-TEE nodes are present in <board>-u-boot.dtsi
-		 * under CONFIG_STM32MP15x_STM32IMAGE only for compatibility
+		 * under CONFIG_STM32MP15X_STM32IMAGE only for compatibility
 		 * when FIP is not used by TF-A
 		 */
-		if (CONFIG_IS_ENABLED(STM32MP15x_STM32IMAGE) &&
+		if (CONFIG_IS_ENABLED(STM32MP15X_STM32IMAGE) &&
 		    !tee_find_device(NULL, NULL, NULL, NULL))
 			stm32_fdt_disable_optee(blob);
 	}
diff --git a/arch/arm/mach-stm32mp/include/mach/bsec.h b/arch/arm/mach-stm32mp/include/mach/bsec.h
index 252eac3946a..10ebc535c4b 100644
--- a/arch/arm/mach-stm32mp/include/mach/bsec.h
+++ b/arch/arm/mach-stm32mp/include/mach/bsec.h
@@ -5,3 +5,10 @@
 
 /* check self hosted debug status = BSEC_DENABLE.DBGSWENABLE */
 bool bsec_dbgswenable(void);
+
+/* Bitfield definition for LOCK status */
+#define BSEC_LOCK_PERM			BIT(30)
+#define BSEC_LOCK_SHADOW_R		BIT(29)
+#define BSEC_LOCK_SHADOW_W		BIT(28)
+#define BSEC_LOCK_SHADOW_P		BIT(27)
+#define BSEC_LOCK_ERROR			BIT(26)
diff --git a/arch/arm/mach-stm32mp/include/mach/etzpc.h b/arch/arm/mach-stm32mp/include/mach/etzpc.h
new file mode 100644
index 00000000000..fd697c3e2ac
--- /dev/null
+++ b/arch/arm/mach-stm32mp/include/mach/etzpc.h
@@ -0,0 +1,32 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later OR BSD-3-Clause */
+/*
+ * Copyright (C) 2023, STMicroelectronics - All Rights Reserved
+ */
+
+#ifndef MACH_ETZPC_H
+#define MACH_ETZPC_H
+
+#include <linux/types.h>
+
+/**
+ * stm32_etzpc_check_access - Check ETZPC accesses for given device node
+ *
+ * @device_node		Node of the device for which the accesses are checked
+ *
+ * @returns 0 on success (if access is granted), -EINVAL if access is denied.
+ *          Else, returns an appropriate negative ERRNO value
+ */
+int stm32_etzpc_check_access(ofnode device_node);
+
+/**
+ * stm32_etzpc_check_access_by_id - Check ETZPC accesses for given id
+ *
+ * @device_node		Node of the device to get a reference on ETZPC
+ * @id			ID of the resource to check
+ *
+ * @returns 0 on success (if access is granted), -EINVAL if access is denied.
+ *          Else, returns an appropriate negative ERRNO value
+ */
+int stm32_etzpc_check_access_by_id(ofnode device_node, u32 id);
+
+#endif /* MACH_ETZPC_H*/
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32.h b/arch/arm/mach-stm32mp/include/mach/stm32.h
index c70375a723c..1912a2274bc 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32.h
@@ -17,7 +17,7 @@
 #define STM32_RCC_BASE			0x50000000
 #define STM32_PWR_BASE			0x50001000
 #define STM32_SYSCFG_BASE		0x50020000
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_DBGMCU_BASE		0x50081000
 #endif
 #define STM32_FMC2_BASE			0x58002000
@@ -28,11 +28,11 @@
 #define STM32_STGEN_BASE		0x5C008000
 #define STM32_TAMP_BASE			0x5C00A000
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_USART1_BASE		0x5C000000
 #define STM32_USART2_BASE		0x4000E000
 #endif
-#ifdef CONFIG_STM32MP13x
+#ifdef CONFIG_STM32MP13X
 #define STM32_USART1_BASE		0x4c000000
 #define STM32_USART2_BASE		0x4c001000
 #endif
@@ -47,7 +47,7 @@
 #define STM32_SDMMC2_BASE		0x58007000
 #define STM32_SDMMC3_BASE		0x48004000
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define STM32_SYSRAM_BASE		0x2FFC0000
 #define STM32_SYSRAM_SIZE		SZ_256K
 #endif
@@ -109,7 +109,7 @@ enum boot_device {
 /* TAMP registers */
 #define TAMP_BACKUP_REGISTER(x)		(STM32_TAMP_BASE + 0x100 + 4 * x)
 
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define TAMP_BACKUP_MAGIC_NUMBER	TAMP_BACKUP_REGISTER(4)
 #define TAMP_BACKUP_BRANCH_ADDRESS	TAMP_BACKUP_REGISTER(5)
 #define TAMP_COPRO_RSC_TBL_ADDRESS	TAMP_BACKUP_REGISTER(17)
@@ -125,7 +125,7 @@ enum boot_device {
 #define TAMP_COPRO_STATE_CRASH		5
 #endif
 
-#ifdef CONFIG_STM32MP13x
+#ifdef CONFIG_STM32MP13X
 #define TAMP_BOOTCOUNT			TAMP_BACKUP_REGISTER(31)
 #define TAMP_BOOT_CONTEXT		TAMP_BACKUP_REGISTER(30)
 #endif
@@ -155,14 +155,14 @@ enum forced_boot_mode {
 #define STM32_BSEC_LOCK(id)		(STM32_BSEC_LOCK_OFFSET + (id) * 4)
 
 /* BSEC OTP index */
-#ifdef CONFIG_STM32MP15x
+#ifdef CONFIG_STM32MP15X
 #define BSEC_OTP_RPN	1
 #define BSEC_OTP_SERIAL	13
 #define BSEC_OTP_PKG	16
 #define BSEC_OTP_MAC	57
 #define BSEC_OTP_BOARD	59
 #endif
-#ifdef CONFIG_STM32MP13x
+#ifdef CONFIG_STM32MP13X
 #define BSEC_OTP_RPN	1
 #define BSEC_OTP_SERIAL	13
 #define BSEC_OTP_MAC	57
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h b/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
index 4ad14f963b4..cb720193e52 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32mp1_smc.h
@@ -15,11 +15,39 @@
  * for SiP (silicon Partner)
  * http://infocenter.arm.com/help/topic/com.arm.doc.den0028a/index.html
  */
-#define STM32_SMC_VERSION		0x82000000
 
 /* Secure Service access from Non-secure */
+
+/*
+ * STM32_SMC_PWR call API
+ *
+ * Argument a0: (input) SMCC ID.
+ *		(output) Status return code.
+ * Argument a1: (input) Service ID (STM32_SMC_REG_xxx).
+ * Argument a2: (input) Register offset or physical address.
+ *		(output) Register read value, if applicable.
+ * Argument a3: (input) Register target value if applicable.
+ */
+#define STM32_SMC_PWR			0x82001001
+
+/*
+ * STM32_SMC_BSEC call API
+ *
+ * Argument a0: (input) SMCC ID
+ *		(output) status return code
+ * Argument a1: (input) Service ID (STM32_SMC_BSEC_xxx)
+ * Argument a2: (input) OTP index
+ *		(output) OTP read value, if applicable
+ * Argument a3: (input) OTP value if applicable
+ */
 #define STM32_SMC_BSEC			0x82001003
 
+/* Service ID for STM32_SMC_PWR */
+#define STM32_SMC_REG_READ		0x0
+#define STM32_SMC_REG_WRITE		0x1
+#define STM32_SMC_REG_SET		0x2
+#define STM32_SMC_REG_CLEAR		0x3
+
 /* Service for BSEC */
 #define STM32_SMC_READ_SHADOW		0x01
 #define STM32_SMC_PROG_OTP		0x02
@@ -30,10 +58,10 @@
 #define STM32_SMC_WRLOCK_OTP		0x07
 
 /* SMC error codes */
-#define STM32_SMC_OK			0x0
-#define STM32_SMC_NOT_SUPPORTED		-1
-#define STM32_SMC_FAILED		-2
-#define STM32_SMC_INVALID_PARAMS	-3
+#define STM32_SMC_OK			0x00000000U
+#define STM32_SMC_NOT_SUPPORTED		0xffffffffU
+#define STM32_SMC_FAILED		0xfffffffeU
+#define STM32_SMC_INVALID_PARAMS	0xfffffffdU
 
 #define stm32_smc_exec(svc, op, data1, data2) \
 	stm32_smc(svc, op, data1, data2, NULL)
diff --git a/arch/arm/mach-stm32mp/include/mach/stm32prog.h b/arch/arm/mach-stm32mp/include/mach/stm32prog.h
index 99be4e1d656..c10bff09c84 100644
--- a/arch/arm/mach-stm32mp/include/mach/stm32prog.h
+++ b/arch/arm/mach-stm32mp/include/mach/stm32prog.h
@@ -10,9 +10,3 @@ int stm32prog_write_medium_virt(struct dfu_entity *dfu, u64 offset,
 int stm32prog_read_medium_virt(struct dfu_entity *dfu, u64 offset,
 			       void *buf, long *len);
 int stm32prog_get_medium_size_virt(struct dfu_entity *dfu, u64 *size);
-
-#ifdef CONFIG_STM32MP15x_STM32IMAGE
-bool stm32prog_get_tee_partitions(void);
-#endif
-
-bool stm32prog_get_fsbl_nor(void);
diff --git a/arch/arm/mach-stm32mp/include/mach/sys_proto.h b/arch/arm/mach-stm32mp/include/mach/sys_proto.h
index f19a70e53e0..0c7d0857073 100644
--- a/arch/arm/mach-stm32mp/include/mach/sys_proto.h
+++ b/arch/arm/mach-stm32mp/include/mach/sys_proto.h
@@ -44,6 +44,7 @@ u32 get_cpu_dev(void);
 #define CPU_REV1_2	0x1003
 #define CPU_REV2	0x2000
 #define CPU_REV2_1	0x2001
+#define CPU_REV2_2	0x2003
 
 /* return Silicon revision = REV_ID[15:0] of Device Version */
 u32 get_cpu_rev(void);
diff --git a/arch/arm/mach-stm32mp/pwr_regulator.c b/arch/arm/mach-stm32mp/pwr_regulator.c
index 846637ab162..c666f9f409f 100644
--- a/arch/arm/mach-stm32mp/pwr_regulator.c
+++ b/arch/arm/mach-stm32mp/pwr_regulator.c
@@ -10,6 +10,7 @@
 #include <errno.h>
 #include <syscon.h>
 #include <asm/io.h>
+#include <asm/arch/stm32mp1_smc.h>
 #include <dm/device_compat.h>
 #include <dm/device-internal.h>
 #include <linux/bitops.h>
@@ -44,6 +45,10 @@ static int stm32mp_pwr_write(struct udevice *dev, uint reg,
 	if (len != 4)
 		return -EINVAL;
 
+	if (IS_ENABLED(CONFIG_ARM_SMCCC) && !IS_ENABLED(CONFIG_SPL_BUILD))
+		return stm32_smc_exec(STM32_SMC_PWR, STM32_SMC_REG_WRITE,
+				      STM32MP_PWR_CR3, val);
+
 	writel(val, priv->base + STM32MP_PWR_CR3);
 
 	return 0;
diff --git a/arch/arm/mach-stm32mp/stm32mp15x.c b/arch/arm/mach-stm32mp/stm32mp15x.c
index 660c907a6ba..afc56b02eea 100644
--- a/arch/arm/mach-stm32mp/stm32mp15x.c
+++ b/arch/arm/mach-stm32mp/stm32mp15x.c
@@ -266,7 +266,7 @@ static const char * const soc_type[] = {
 };
 
 static const char * const soc_pkg[] = { "??", "AD", "AC", "AB", "AA" };
-static const char * const soc_rev[] = { "?", "A", "B", "Z" };
+static const char * const soc_rev[] = { "?", "A", "B", "Z", "Y"};
 
 static void get_cpu_string_offsets(unsigned int *type, unsigned int *pkg,
 				   unsigned int *rev)
@@ -307,6 +307,9 @@ static void get_cpu_string_offsets(unsigned int *type, unsigned int *pkg,
 	case CPU_REV2_1:
 		*rev = 3;
 		break;
+	case CPU_REV2_2:
+		*rev = 4;
+		break;
 	default:
 		*rev = 0;
 		break;
-- 
2.17.1

